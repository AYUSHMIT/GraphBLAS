TODO: MATLAB: GrB.load and GrB.save, as an object or optionally a struct
    (Octave can't save an object and requires the latter)

FUTURE: can handle transpose of full or bitmap input matrices just by
changing how they are accessed


--------------------------------------------------------------------------------
BC:

phase1:

    [ GrB_apply (shallow-op) 0.00333 sec ]
    [ GrB_assign (C full) (C full) Method 23: (C full) += Z 0.0175 sec ]
    [ GrB_mxm (M full) C<!M>=A*B, saxpy axbflops 6.41067e+09 Mwork 5.36871e+08 (use mask) nthreads 40 ntasks 162 coarse: (gus: 0 hash: 0) fine: (gus: 162 hash: 0) 11.5 sec ]
    [ GrB_Matrix_nvals 4.97e-07 sec ]

mask is full -- no need to scatter it into Gustavson workspace
Fine Gus (same as BFS)

mask is float (32-bit)

phase2: how to make this faster?

    [ GrB_mxm C<M>=A*B, saxpy axbflops 1.03031e+10 Mwork 1.04727e+07 (use mask) nthreads 40 ntasks 163 coarse: (gus: 0 hash: 0) fine: (gus: 163 hash: 0) 12.7 sec ]


--------------------------------------------------------------------------------
CC:

    lots of conversion of full to sparse for vector export.
    eWiseAdd: sparse to full

    [ GrB_mxv (C full) (B full) C=A'*B, dot_product dense, C+=A'*B in place 0.331 sec ]
    [ GrB_eWiseAdd (C full) (A full) (B full) dense C+=A+B 0.0341 sec ]
    [ GrB_Vector_extractTuples (A full) 0.0216 sec ]
    [ GrB_extract (A full) 0.131 sec ]
    [ GrB_eWiseMult (A full) (B full) dense C=A+B (to full) 0.0206 sec ]
    [ GrB_reduce (A full) 0.000173 sec ]
    [ GrB_mxv (C full) (B full) C=A'*B, dot_product dense, C+=A'*B in place 0.178 sec ]
    [ GxB_Vector_export (full to sparse) 0.054 sec ]
    [ GxB_Vector_export (full to sparse) 0.0549 sec ]
    [ GxB_Vector_import 3.06e-06 sec ]
    [ GxB_Vector_import 1.14e-06 sec ]
    [ GrB_eWiseAdd (C dense) (A dense) (B full) dense C+=A+B (sparse to full) 0.0337 sec ]

TODO: need a matrix/vector import/export that never does conversion

--------------------------------------------------------------------------------
PR:

    eWiseMult: output converted to full (prior was empty), just once

    [ GrB_assign (C empty) Method 21: (C full) = scalar 0.0189 sec ]
    [ GrB_Vector_dup (A full) 0.0222 sec ]
    [ GrB_assign (C full) (C full) Method 22: (C full) += scalar 0.0188 sec ]

    each iteration:

    [ GrB_eWiseMult (A full) (B full) dense C=A+B (to full) 0.0332 sec ]
    [ GrB_assign (C empty) Method 21: (C full) = scalar 0.0182 sec ]
    [ GrB_mxv (C full) (B full) C=A'*B, dot_product dense, C+=A'*B in place 2.99 sec ]
    [ GrB_assign (C full) (A full) (C full) Method 23: (C full) += Z (Z dense) 0.0255 sec ]
    [ GrB_apply (C full) (A full) (inplace-op) 0.0193 sec ]
    [ GrB_reduce (A full) 0.00881 sec ]

TODO: constant-valued matrices/vectors (for r(:)=teleport)
    probably coupled with lazy malloc/free of A->x when converting from
    full (non-constant) to constant-valued

need aggressive exploit of non-blocking mode, to speedup x = sum (abs (t-r))


