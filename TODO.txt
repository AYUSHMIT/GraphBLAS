THIS IS A DRAFT.  The following features/revisions will appear in the stable
v8.0.0 release:

* NOTE: remove prior JIT kernels!

    If you have JIT kernels in your ~/.SuiteSparse/GraphBLAS/8.0.0 folder,
    delete them.  Normally, a new version of GraphBLAS will create a new folder
    and ignore the old one, but this draft is still numbered 8.0.0.  Its
    kernels are incompatible with the earlier DRAFT* versions of 8.0.0,
    however.

* Atomics:

    Can some "seq_cst" atomic clauses be safely removed?  I'm unsure.
    The current version gives correct results on the Arm (see the bug fix
    made for v7.4.4, also included here).

* Windows:

    The JIT needs to be ported to Windows.  This draft will not compile on
    Windows with the JIT enabled.  I think it will compile with -DNJIT
    but I haven't tested it.

* compiler warnings: should be fixed now

    using clang leads to some compiler warnings when compiling the demos
    (typecasting complex types).  These are safe but need to be silenced.

* better performance:

    This draft is thread-safe when used in a multithread user application,
    but a better JIT critical section (many readers, 1 writer) is needed.
    The current critical section may be sufficiently fast since the typical
    case of work done inside the critical section is a single hash table
    lookup.  However, the performance issues related to this have not been
    tested.

* FIXMEs:

    Some FIXME's tagged in the Source/ folder.
    These need to be done for v8.0.0.

* Thread-safety:

    GraphBLAS is thread-safe when used in a single multithreaded user
    application, even when multiple user threads try to compile the same JIT
    kernel at the same time.  However, if the user runs multiple instances of
    GraphBLAS at the same time, from entirely different user processes, and
    each of them attempts to compile the same JIT kernels, a file read/write
    conflict will occur on your ~/.SuiteSparse/GraphBLAS/8.0.0 folder.  I need
    a portable file-locking mechanism for Linux/Unix, Mac, and Windows.  As a
    short-term workaround, each user application should use its own cache
    folder, instead of sharing a single default cache folder.

