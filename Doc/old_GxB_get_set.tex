
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{SuiteSparse:GraphBLAS Options (OLD)} %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\label{options}

SuiteSparse:GraphBLAS includes two type-generic methods, \verb'GxB_set' and
\verb'GxB_get', that set and query various options and parameters settings,
including a generic way to set values in the \verb'GrB_Descriptor' object.
Using these methods, the user application can provide hints to
SuiteSparse:GraphBLAS on how it should store and operate on its matrices.
These hints have no effect on the results of any GraphBLAS operation (except
perhaps floating-point roundoff differences), but they can have a great impact
on the amount of time or memory taken.

\begin{note}
{\bf NOTE:} In the next release, \verb'GxB_get' and \verb'GxB_set' will be
replaced by \verb'GrB_*_get' and \verb'GrB_*_set', using the v2.1 C API
Specification.
\end{note}

%-------------------------------------------------------------------------------
\subsection{{\sf GxB\_set}: overview}
%-------------------------------------------------------------------------------

\begin{itemize}

\item \verb'GxB_set (field, value)' sets global options.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_HYPER_SWITCH'     & \verb'double' & hypersparsity control (0 to 1) \\
\verb'GxB_BITMAP_SWITCH'    & \verb'double [8]' & bitmap control \\
\verb'GxB_FORMAT'           & \verb'int'    & \verb'GxB_BY_ROW'
                                              or \verb'GxB_BY_COL' \\
\verb'GxB_GLOBAL_NTHREADS'  & \verb'int'    & number of threads to use \\
\verb'GxB_NTHREADS'         & \verb'int'    & number of threads to use \\
\verb'GxB_GLOBAL_CHUNK'     & \verb'double' & chunk size \\
\verb'GxB_CHUNK'            & \verb'double' & chunk size \\
\verb'GxB_BURBLE'           & \verb'int'    & diagnostic output \\
\verb'GxB_PRINTF'           & see below     & diagnostic output \\
\verb'GxB_FLUSH'            & see below     & diagnostic output \\
\verb'GxB_PRINT_1BASED'     & \verb'int'    & for printing matrices/vectors \\
\hline
\verb'GxB_JIT_C_COMPILER_NAME' & \verb'char *' & C compiler for JIT kernels \\
\verb'GxB_JIT_C_COMPILER_FLAGS'& \verb'char *' & flags for the C compiler \\
\verb'GxB_JIT_C_LINKER_FLAGS' & \verb'char *' & link flags for the C compiler \\
\verb'GxB_JIT_C_LIBRARIES'    & \verb'char *' & libraries to link against \\
\verb'GxB_JIT_C_CMAKE_LIBS'   & \verb'char *' & libraries to link against \\
\verb'GxB_JIT_C_PREFACE'      & \verb'char *' & C code as preface to JIT kernels \\
\verb'GxB_JIT_C_CONTROL'      & see Section \ref{jit} & CPU JIT control \\
\verb'GxB_JIT_USE_CMAKE'      & see Section \ref{jit} & CPU JIT: use cmake \\
\verb'GxB_JIT_ERROR_LOG'      & \verb'char *' & error log file \\
\verb'GxB_JIT_CACHE_PATH'     & \verb'char *' & folder with compiled kernels \\
\hline
\end{tabular}
}

\item \verb'GxB_set (GrB_Matrix A, field, value)' provides hints to
    SuiteSparse: GraphBLAS on how to store a particular matrix.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_HYPER_SWITCH'     & \verb'double' & hypersparsity control (0 to 1) \\
\verb'GxB_BITMAP_SWITCH'    & \verb'double' & bitmap control (0 to 1) \\
\verb'GxB_FORMAT'           & \verb'int'    & \verb'GxB_BY_ROW'
                                              or \verb'GxB_BY_COL' \\
\verb'GxB_SPARSITY_CONTROL' & \verb'int'    & 0 to 15 \\
\hline
\end{tabular}
}

\item \verb'GxB_set (GrB_Vector v, field, value)' provides hints to
    SuiteSparse: GraphBLAS on how to store a particular vector.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_BITMAP_SWITCH'    & \verb'double' & bitmap control (0 to 1) \\
\verb'GxB_SPARSITY_CONTROL' & \verb'int'    & 0 to 15 \\
\hline
\end{tabular}
}

\item \verb'GxB_set (GrB_Descriptor desc, field, value)' sets
    the value of a field in a \verb'GrB_Descriptor'.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GrB_OUTP'     & \verb'GrB_Desc_Value' & replace option \\
\verb'GrB_MASK'     & \verb'GrB_Desc_Value' & mask option \\
\verb'GrB_INP0'     & \verb'GrB_Desc_Value' & transpose input 0 \\
\verb'GrB_INP1'     & \verb'GrB_Desc_Value' & transpose input 1 \\
\verb'GxB_AxB_METHOD'           & \verb'int' & method for matrix multiply \\
\verb'GxB_SORT'                 & \verb'int' & lazy vs aggressive sort \\
\verb'GxB_COMPRESSION'          & \verb'int' & compression for serialization \\
\verb'GxB_IMPORT'    & \verb'GrB_Desc_Value' & trust data on import/pack \\
\hline
\end{tabular}
}

\item \verb'GxB_set (GxB_Context desc, field, value)' sets
    the value of a field in a \verb'GxB_Context'.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_NTHREADS'         & \verb'int'    & number of threads to use \\
\verb'GxB_CHUNK'            & \verb'double' & chunk size \\
\hline
\end{tabular}
}

\end{itemize}

%-------------------------------------------------------------------------------
\subsection{{\sf GxB\_get}: overview}
%-------------------------------------------------------------------------------

\verb'GxB_get' queries a \verb'GrB_Descriptor', a \verb'GrB_Matrix',
a \verb'GrB_Vector', or the global options.

\begin{itemize}

\item \verb'GxB_get (field, &value)' retrieves the value of a global option.
NOTE: the \verb'const char *' values returned by \verb'GxB_get' are pointers
to memory spaces ``owned'' by the GraphBLAS library.  Do not modify them.
Subsequent calls to GraphBLAS (particularly setting the JIT control strings)
can change those strings.  The user application must copy those strings into
its own memory space if the strings are to be kept.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_HYPER_SWITCH'     & \verb'double' & hypersparsity control (0 to 1) \\
\verb'GxB_BITMAP_SWITCH'    & \verb'double [8]' & bitmap control \\
\verb'GxB_FORMAT'           & \verb'int'    & \verb'GxB_BY_ROW' or \verb'GxB_BY_COL' \\
\verb'GxB_GLOBAL_NTHREADS'  & \verb'int'    & number of threads to use \\
\verb'GxB_NTHREADS'         & \verb'int'    & number of threads to use \\
\verb'GxB_GLOBAL_CHUNK'     & \verb'double' & chunk size \\
\verb'GxB_CHUNK'            & \verb'double' & chunk size \\
\verb'GxB_BURBLE'           & \verb'int'    & diagnostic output \\
\verb'GxB_PRINTF'           & see below     & diagnostic output \\
\verb'GxB_FLUSH'            & see below     & diagnostic output \\
\verb'GxB_PRINT_1BASED'     & \verb'int'    & for printing matrices/vectors \\
\hline
\verb'GxB_JIT_C_COMPILER_NAME' & \verb'const char *' & C compiler for JIT kernels \\
\verb'GxB_JIT_C_COMPILER_FLAGS'& \verb'const char *' & flags for the C compiler \\
\verb'GxB_JIT_C_LINKER_FLAGS' & \verb'const char *' & link flags for the C compiler \\
\verb'GxB_JIT_C_LIBRARIES'    & \verb'const char *' & libraries to link against \\
\verb'GxB_JIT_C_CMAKE_LIBS'   & \verb'const char *' & libraries to link against \\
\verb'GxB_JIT_C_PREFACE'      & \verb'const char *' & C code as preface to JIT kernels \\
\verb'GxB_JIT_C_CONTROL'      & see Section \ref{jit} & CPU JIT control \\
\verb'GxB_JIT_USE_CMAKE'      & see Section \ref{jit} & CPU JIT: use cmake \\
\verb'GxB_JIT_ERROR_LOG'      & \verb'const char *' & error log file \\
\verb'GxB_JIT_CACHE_PATH'     & \verb'const char *' & folder with compiled kernels \\
\hline
\verb'GxB_MODE'                 & \verb'int'    & blocking/non-blocking \\
\verb'GxB_LIBRARY_NAME'         & \verb'const char *' & name of library \\
\verb'GxB_LIBRARY_VERSION'      & \verb'int [3]' & library version \\
\verb'GxB_LIBRARY_DATE'         & \verb'const char *' & release date \\
\verb'GxB_LIBRARY_ABOUT'        & \verb'const char *' & about the library \\
\verb'GxB_LIBRARY_LICENSE'      & \verb'const char *' & license \\
\verb'GxB_LIBRARY_COMPILE_DATE' & \verb'const char *' & date of compilation \\
\verb'GxB_LIBRARY_COMPILE_TIME' & \verb'const char *' & time of compilation \\
\verb'GxB_LIBRARY_OPENMP'       & \verb'bool'   & true if compiled with OpenMP\\
\verb'GxB_LIBRARY_URL'          & \verb'const char *' & url of library \\
\verb'GxB_API_VERSION'          & \verb'int [3]' & C API version \\
\verb'GxB_API_DATE'             & \verb'const char *' & C API date \\
\verb'GxB_API_ABOUT'            & \verb'const char *' & about the C API \\
\verb'GxB_API_URL'              & \verb'const char *' & \verb'http://graphblas.org' \\
\verb'GxB_COMPILER_NAME'        & \verb'const char *' & C compiler name \\
\verb'GxB_COMPILER_VERSION'     & \verb'int [3]' & C compiler version \\
\hline
\end{tabular}
}

\newpage
\item \verb'GxB_get (GrB_Matrix A, field, &value)' retrieves the current
    value of an option from a particular matrix \verb'A'.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_HYPER_SWITCH'     & \verb'double' & hypersparsity control (0 to 1) \\
\verb'GxB_BITMAP_SWITCH'    & \verb'double' & bitmap control (0 to 1) \\
\verb'GxB_FORMAT'           & \verb'int'    & \verb'GxB_BY_ROW'
                                              or \verb'GxB_BY_COL' \\
\verb'GxB_SPARSITY_CONTROL' & \verb'int'    & 0 to 15 \\
\verb'GxB_SPARSITY_STATUS'  & \verb'int'    & 1, 2, 4, or 8 \\
\hline
\end{tabular}
}

\item \verb'GxB_get (GrB_Vector A, field, &value)' retrieves the current
    value of an option from a particular vector \verb'v'.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_BITMAP_SWITCH'    & \verb'double' & bitmap control (0 to 1) \\
\verb'GxB_FORMAT'           & \verb'int'    & \verb'GxB_BY_ROW'
                                              or \verb'GxB_BY_COL' \\
\verb'GxB_SPARSITY_CONTROL' & \verb'int'    & 0 to 15 \\
\verb'GxB_SPARSITY_STATUS'  & \verb'int'    & 1, 2, 4, or 8 \\
\hline
\end{tabular}
}

\item \verb'GxB_get (GrB_Descriptor desc, field, &value)' retrieves the value
    of a field in a descriptor.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GrB_OUTP'     & \verb'GrB_Desc_Value' & replace option \\
\verb'GrB_MASK'     & \verb'GrB_Desc_Value' & mask option \\
\verb'GrB_INP0'     & \verb'GrB_Desc_Value' & transpose input 0 \\
\verb'GrB_INP1'     & \verb'GrB_Desc_Value' & transpose input 1 \\
\verb'GxB_AxB_METHOD'           & \verb'int' & method for matrix multiply \\
\verb'GxB_SORT'                 & \verb'int' & lazy vs aggressive sort \\
\verb'GxB_COMPRESSION'          & \verb'int' & compression for serialization \\
\verb'GxB_IMPORT'    & \verb'GrB_Desc_Value' & trust data on import/pack \\
\hline
\end{tabular}
}

\item \verb'GxB_get (GxB_Context desc, field, value)' retrieves
    the value of a field in a \verb'GxB_Context'.

{\footnotesize
\begin{tabular}{lll}
field                       & value         & description \\
\hline
\verb'GxB_NTHREADS'         & \verb'int'    & number of threads to use \\
\verb'GxB_CHUNK'            & \verb'double' & chunk size \\
\hline
\end{tabular}
}

\end{itemize}

%-------------------------------------------------------------------------------
\newpage
\subsection{OpenMP parallelism}
%-------------------------------------------------------------------------------
\label{omp_parallelism}

SuiteSparse:GraphBLAS is a parallel library, based on OpenMP.  By
default, all GraphBLAS operations will use up to the maximum number of threads
specified by the \verb'omp_get_max_threads' OpenMP function.  For small
problems, GraphBLAS may choose to use fewer threads, using two parameters: the
maximum number of threads to use (which may differ from the
\verb'omp_get_max_threads' value), and a parameter called the \verb'chunk'.
Suppose \verb'work' is a measure of the work an operation needs to perform (say
the number of entries in the two input matrices for \verb'GrB_eWiseAdd').  No
more than \verb'floor(work/chunk)' threads will be used (or one thread if the
ratio is less than 1).

\verb'GxB_NTHREADS' controls how many threads a method uses.
    By default (if set to zero, or \verb'GrB_DEFAULT'), all available threads
    are used.  The maximum available threads is controlled by the global
    setting, which is \verb'omp_get_max_threads ( )' by default.  If set to
    some positive integer \verb'nthreads' less than this maximum, at most
    \verb'nthreads' threads will be used.

\verb'GxB_CHUNK' is a \verb'double' value that controls how many threads
    a method uses for small problems.
The default \verb'chunk' value is 65,536, but this may change in future
versions, or it may be modified when GraphBLAS is installed on a particular
machine.

Both parameters can be set in two ways:

\begin{itemize}

\item Globally:  If the following methods are used, then all subsequent
GraphBLAS operations will use these settings.  Note the typecast,
\verb'(double)' \verb'chunk'.  This is necessary if a literal constant such as
\verb'20000' is passed as this argument.  The type of the constant must be
\verb'double'.

    {\footnotesize
    \begin{verbatim}
    int nthreads_max = 40 ;
    GxB_set (GxB_NTHREADS, nthreads_max) ;
    GxB_set (GxB_CHUNK, (double) 20000) ; \end{verbatim} }

\item Context: this object can be used to choose a different number of
threads used in calls to GraphBLAS from different user threads, exploiting
nested parallelism.  Refer to Section~\ref{context}.  If a thread has engaged a
context object, it ignores the global settings for \verb'GxB_NTHREADS' and
\verb'GxB_CHUNK', and uses the settings in its own context instead.

\end{itemize}

The smaller of \verb'nthreads_max' and \verb'floor(work/chunk)' is used for any
given GraphBLAS operation, except that a single thread is used if this value is
zero or less.

If either parameter is set to \verb'GrB_DEFAULT', then default values are used.
The default for \verb'nthreads_max' is the return value from
\verb'omp_get_max_threads', and the default chunk size is currently 65,536.

If a descriptor value for either parameter is left at its default, or set to
\verb'GrB_DEFAULT', then the global setting is used.  This global setting may
have been modified from its default, and this modified value will be used.

For example, suppose \verb'omp_get_max_threads' reports 8 threads.  If \newline
\verb'GxB_set (GxB_NTHREADS, 4)' is used, then the global setting is four
threads, not eight.

GraphBLAS may be compiled without OpenMP, by setting \verb'-DNOPENMP=1'.
The library will be thread-safe, with one exception.  \verb'GrB_wait' is
intended to provide thread-safety by flushing the cache of one user thread
so the object can be safely read by another thread.  This is accomplished
with \verb'pragma omp flush', but if OpenMP is not available, this does
nothing.  If OpenMP is not available or \verb'-DNOPEMP=1' is used, then
user applications need to ensure their own thread safety when one user thread
computes a result that is then read by another thread.

You can query GraphBLAS at run-time to ask if it was compiled with OpenMP:

\begin{verbatim}
    bool have_openmp ;
    GxB_get (GxB_LIBRARY_OPENMP, &have_openmp) ;
    if (!have_openmp) printf ("GraphBLAS not compiled with OpenMP\n") :
\end{verbatim}

Compiling GraphBLAS without OpenMP is not recommended for installation in a
package manager (Linux, conda-forge, spack, brew, vcpkg, etc).

%-------------------------------------------------------------------------------
\subsection{Storing a matrix by row or by column}
%-------------------------------------------------------------------------------

The GraphBLAS \verb'GrB_Matrix' is entirely opaque to the user application, and
the GraphBLAS API does not specify how the matrix should be stored.  However,
choices made in how the matrix is represented in a particular implementation,
such as SuiteSparse:GraphBLAS, can have a large impact on performance.

Many graph algorithms are just as fast in any format, but some algorithms are
much faster in one format or the other.  For example, suppose the user
application stores a directed graph as a matrix \verb'A', with the edge $(i,j)$
represented as the value \verb'A(i,j)', and the application makes many accesses
to the $i$th row of the matrix, with \verb'GrB_Col_extract'
\verb'(w,...,A,GrB_ALL,...,i,desc)' with the transposed descriptor
(\verb'GrB_INP0' set to \verb'GrB_TRAN').  If the matrix is stored by column
this can be extremely slow, just like the expression \verb'w=A(i,:)' in MATLAB,
where \verb'i' is a scalar.  Since this is a typical use-case in graph
algorithms, the default format in SuiteSparse:GraphBLAS is to store its
matrices by row, in Compressed Sparse Row format (CSR).

MATLAB stores its sparse matrices by column, in ``non-hypersparse'' format, in
what is called the Compressed Sparse Column format, or CSC for short.  An
\verb'm'-by-\verb'n' matrix in MATLAB is represented as a set of \verb'n'
column vectors, each with a sorted list of row indices and values of the
nonzero entries in that column.  As a result, \verb'w=A(:,j)' is very fast in
MATLAB, since the result is already held in the data structure a single list,
the $j$th column vector.  However, \verb'w=A(i,:)' is very slow in MATLAB,
since every column in the matrix has to be searched to see if it contains row
\verb'i'.  In MATLAB, if many such accesses are made, it is much better to
transpose the matrix (say \verb"AT=A'") and then use \verb"w=AT(:,i)" instead.
This can have a dramatic impact on the performance of MATLAB.

Likewise, if \verb'u' is a very sparse column vector and \verb'A' is stored by
column, then \verb"w=u'*A" (via \verb'GrB_vxm') is slower than \verb'w=A*u'
(via \verb'GrB_mxv').  The opposite is true if the matrix is stored by row.

SuiteSparse:GraphBLAS stores its matrices by row, by default (with one
exception described below).  However, it can also be instructed to store any
selected matrices, or all matrices, by column instead (just like MATLAB), so
that \verb'w=A(:,j)' (via \verb'GrB_Col_extract') is very fast.  The change in
data format has no effect on the result, just the time and memory usage.  To
use a column-oriented format by default, the following can be done in a user
application that tends to access its matrices by column.

    {\footnotesize
    \begin{verbatim}
    GrB_init (...) ;
    // just after GrB_init: do the following:
    #ifdef GxB_SUITESPARSE_GRAPHBLAS
    GxB_set (GxB_FORMAT, GxB_BY_COL) ;
    #endif \end{verbatim} }

If this is done, and no other \verb'GxB_set' calls are made with
\verb'GxB_FORMAT', all matrices will be stored by column.
The default format is \verb'GxB_BY_ROW'.

All vectors (\verb'GrB_Vector') are held by column, and this cannot be changed.

By default, matrices of size \verb'm-by-1' are held by column, regardless of
the global setting described above.  Matrices of size \verb'1-by-n' with
\verb'n' not equal to 1 are held by row, regardless of the global setting.
The global setting only affects matrices with both \verb'm > 1' and \verb'n > 1'.
Empty matrices (\verb'0-by-0') are also controlled by the global setting.

After creating a matrix with \verb'GrB_Matrix_new (&A, ...)',
its format can be changed arbitrarily with \verb'GxB_set (A, GxB_FORMAT, ...)'.
So even an \verb'm-by-1' matrix can then be changed to be held by row, for
example.  Likewise, once a \verb'1-by-n' matrix is created, it can be converted
to column-oriented format.

%-------------------------------------------------------------------------------
\subsection{Hypersparse matrices}
\label{hypersparse}
%-------------------------------------------------------------------------------

MATLAB can store an \verb'm'-by-\verb'n' matrix with a very large value of
\verb'm', since a CSC data structure takes $O(n+|{\bf A}|)$ memory, independent
of \verb'm', where $|{\bf A}|$ is the number of nonzeros in the matrix.  It
cannot store a matrix with a huge \verb'n', and this structure is also
inefficient when $|{\bf A}|$ is much smaller than \verb'n'.  In contrast,
SuiteSparse:GraphBLAS can store its matrices in {\em hypersparse} format,
taking only $O(|{\bf A}|)$ memory, independent of how it is stored (by row or
by column) and independent of both \verb'm' and \verb'n'
\cite{BulucGilbert08,BulucGilbert12}.

In both the CSR and CSC formats, the matrix is held as a set of sparse vectors.
In non-hypersparse format, the set of sparse vectors is itself dense; all
vectors are present, even if they are empty.  For example, an
\verb'm'-by-\verb'n' matrix in non-hypersparse CSC format contains \verb'n'
sparse vectors.  Each column vector takes at least one integer to represent,
even for a column with no entries.  This allows for quick lookup for a
particular vector, but the memory required is $O(n+|{\bf A}|)$.  With a
hypersparse CSC format, the set of vectors itself is sparse, and columns with
no entries take no memory at all.  The drawback of the hypersparse format is
that finding an arbitrary column vector \verb'j', such as for the computation
\verb'C=A(:,j)', takes $O(\log k)$ time if there $k \le n$ vectors in the data
structure.  One advantage of the hypersparse structure is the memory required
for an \verb'm'-by-\verb'n' hypersparse CSC matrix is only $O(|{\bf A}|)$,
independent of \verb'm' and \verb'n'.  Algorithms that must visit all non-empty
columns of a matrix are much faster when working with hypersparse matrices,
since empty columns can be skipped.

The \verb'hyper_switch' parameter controls the hypersparsity of the internal
data structure for a matrix.  The parameter is typically in the range 0 to 1.
The default is \verb'hyper_switch' = \verb'GxB_HYPER_DEFAULT', which is an
\verb'extern' \verb'const' \verb'double' value, currently set to 0.0625, or
1/16.  This default ratio may change in the future.

The \verb'hyper_switch' determines how the matrix is converted between the
hypersparse and non-hypersparse formats.  Let $n$ be the number of columns of a
CSC matrix, or the number of rows of a CSR matrix.  The matrix can have at most
$n$ non-empty vectors.

Let $k$ be the actual number of non-empty vectors.  That is, for the CSC
format, $k \le n$ is the number of columns that have at least one entry.  Let
$h$ be the value of \verb'hyper_switch'.

If a matrix is currently hypersparse, it can be converted to non-hypersparse if
the either condition $n \le 1$ or $k > 2nh$ holds, or both.  Otherwise, it
stays hypersparse.  Note that if $n \le 1$ the matrix is always stored as
non-hypersparse.

If currently non-hypersparse, it can be converted to hypersparse if
both conditions $n > 1$ and $k \le nh$ hold.  Otherwise, it stays
non-hypersparse.  Note that if $n \le 1$ the matrix always remains
non-hypersparse.

The default value of \verb'hyper_switch' is assigned at startup by
\verb'GrB_init', and can then be modified globally with \verb'GxB_set'.  All
new matrices are created with the same \verb'hyper_switch', determined by the
global value.  Once a particular matrix \verb'A' has been constructed, its
hypersparsity ratio can be modified from the default with:

    {\footnotesize
    \begin{verbatim}
    double hyper_switch = 0.2 ;
    GxB_set (A, GxB_HYPER_SWITCH, hyper_switch) ; \end{verbatim}}

To force a matrix to always be non-hypersparse, use \verb'hyper_switch' equal to
\verb'GxB_NEVER_HYPER'.  To force a matrix to always stay hypersparse, set
\verb'hyper_switch' to \verb'GxB_ALWAYS_HYPER'.

A \verb'GrB_Matrix' can thus be held in one of four formats: any combination of
hyper/non-hyper and CSR/CSC.  All \verb'GrB_Vector' objects are always stored
in non-hypersparse CSC format.

A new matrix created via \verb'GrB_Matrix_new' starts with $k=0$ and is created
in hypersparse form by default unless $n \le 1$ or if $h<0$, where $h$ is the
global \verb'hyper_switch' value.  The matrix is created in either
\verb'GxB_BY_ROW' or \verb'GxB_BY_COL' format, as determined by the last call
to \verb'GxB_set(GxB_FORMAT,...)' or \verb'GrB_init'.

A new matrix \verb'C' created via \verb'GrB_dup (&C,A)' inherits the CSR/CSC
format, hypersparsity format, and \verb'hyper_switch' from \verb'A'.

%-------------------------------------------------------------------------------
\subsection{Bitmap matrices}
\label{bitmap_switch}
%-------------------------------------------------------------------------------

By default, SuiteSparse:GraphBLAS switches between all four formats
(hypersparse, sparse, bitmap, and full) automatically.  Let $d = |{\bf A}|/mn$
for an $m$-by-$n$ matrix $\bf A$ with $|{\bf A}|$ entries.  If the matrix is
currently in sparse or hypersparse format, and is modified so that $d$ exceeds
a given threshold, it is converted into bitmap format.  The default threshold
is controlled by the \verb'GxB_BITMAP_SWITCH' setting, which can be set
globally, or for a particular matrix or vector.

The default value of the switch to bitmap format depends on $\min(m,n)$, for a
matrix of size $m$-by-$n$.  For the global setting, the bitmap switch is a
\verb'double' array of size \verb'GxB_NBITMAP_SWITCH'.  The defaults are given
below:

\vspace{0.2in}
{\small
\begin{tabular}{lll}
parameter & default & matrix sizes \\
\hline
\verb'bitmap_switch [0]' & 0.04 & $\min(m,n) = 1$ (and all vectors) \\
\verb'bitmap_switch [1]' & 0.05 & $\min(m,n) = 2$ \\
\verb'bitmap_switch [2]' & 0.06 & $\min(m,n) = 3$ to 4 \\
\verb'bitmap_switch [3]' & 0.08 & $\min(m,n) = 5$ to 8 \\
\verb'bitmap_switch [4]' & 0.10 & $\min(m,n) = 9$ to 16\\
\verb'bitmap_switch [5]' & 0.20 & $\min(m,n) = 17$ to 32\\
\verb'bitmap_switch [6]' & 0.30 & $\min(m,n) = 33$ to 64 \\
\verb'bitmap_switch [7]' & 0.40 & $\min(m,n) > 64$ \\
\end{tabular}
}
\vspace{0.2in}

That is, by default a \verb'GrB_Vector' is held in bitmap format if its density
exceeds 4\%.  To change the global settings, do the following:

{\footnotesize
\begin{verbatim}
    double bswitch [GxB_NBITMAP_SWITCH] = { 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8 } ;
    GxB_set (GxB_BITMAP_SWITCH, bswitch) ;
\end{verbatim}
}

If the matrix is currently in bitmap format, it is converted to full if all
entries are present, or to sparse/hypersparse if $d$ drops below $b/2$, if its
bitmap switch is $b$.  A matrix or vector with $d$ between $b/2$ and $b$
remains in its current format.

%-------------------------------------------------------------------------------
\subsection{Parameter types}
%-------------------------------------------------------------------------------
The \verb'GxB_Option_Field' enumerated type gives the type of the \verb'field'
parameter for the second argument of \verb'GxB_set' and \verb'GxB_get',
for setting global options or matrix options.

NOTE: The enum values have changed with v8.0.0, to be compatible with the
future updates from the v2.1 C API specification.

{\footnotesize
\begin{verbatim}
\end{verbatim} }

The \verb'GxB_FORMAT' field can be by row or by column, set to a value
with the type \verb'GxB_Format_Value':

{\footnotesize
\begin{verbatim}
typedef enum
{
    GxB_BY_ROW = 0,     // CSR: compressed sparse row format
    GxB_BY_COL = 1      // CSC: compressed sparse column format
}
GxB_Format_Value ;
\end{verbatim} }

The default format is given by the predefined value \verb'GxB_FORMAT_DEFAULT',
which is equal to \verb'GxB_BY_ROW'.
The default hypersparsity
ratio is 0.0625 (1/16), but this value may change in the future.

Setting the \verb'GxB_HYPER_SWITCH' field to \verb'GxB_ALWAYS_HYPER' ensures a matrix
always stays hypersparse.  If set to \verb'GxB_NEVER_HYPER', it always stays
non-hypersparse.  At startup, \verb'GrB_init' defines the following initial
settings:

{\footnotesize
\begin{verbatim}
    GxB_set (GxB_HYPER_SWITCH, GxB_HYPER_DEFAULT) ;
    GxB_set (GxB_FORMAT, GxB_BY_ROW) ;
\end{verbatim} }

That is, by default, all new matrices are held by row in CSR format (except
for \verb'n-by-1' matrices; see \verb'GrB_Matrix_new').
If a matrix has fewer than $n/16$
columns, it can be converted to hypersparse format.  If it has more than $n/8$
columns, it can be converted to non-hypersparse format.  These options can be
changed for all future matrices with \verb'GxB_set'.  For example, to change
all future matrices to be in non-hypersparse CSC when created, use:

{\footnotesize
\begin{verbatim}
    GxB_set (GxB_HYPER_SWITCH, GxB_NEVER_HYPER) ;
    GxB_set (GxB_FORMAT, GxB_BY_COL) ;
\end{verbatim} }

Then if a particular matrix needs a different format, then (as an example):

{\footnotesize
\begin{verbatim}
    GxB_set (A, GxB_HYPER_SWITCH, 0.1) ;
    GxB_set (A, GxB_FORMAT, GxB_BY_ROW) ;
\end{verbatim} }

This changes the matrix \verb'A' so that it is stored by row, and it is
converted from non-hypersparse to hypersparse format if it has fewer than 10\%
non-empty columns.  If it is hypersparse, it is a candidate for conversion to
non-hypersparse if has 20\% or more non-empty columns.  If it has between 10\%
and 20\% non-empty columns, it remains in its current format.
MATLAB only supports a non-hypersparse CSC format.  The format in
SuiteSparse:GraphBLAS that is equivalent to the MATLAB format is:

{\footnotesize
\begin{verbatim}
    GrB_init (...) ;
    GxB_set (GxB_HYPER_SWITCH, GxB_NEVER_HYPER) ;
    GxB_set (GxB_FORMAT, GxB_BY_COL) ;
    // no subsequent use of GxB_HYPER_SWITCH or GxB_FORMAT
\end{verbatim} }

The \verb'GxB_HYPER_SWITCH' and \verb'GxB_FORMAT' options should be considered as
suggestions from the user application as to how SuiteSparse:GraphBLAS can
obtain the best performance for a particular application.
SuiteSparse:GraphBLAS is free to ignore any of these suggestions, both now and
in the future, and the available options and formats may be augmented in the
future.  Any prior options no longer needed in future versions of
SuiteSparse:GraphBLAS will be silently ignored, so the use these options is
safe for future updates.

The sparsity status of a matrix can be queried with the following, which
returns a value of \verb'GxB_HYPERSPARSE' \verb'GxB_SPARSE' \verb'GxB_BITMAP'
or \verb'GxB_FULL'.

{\footnotesize
\begin{verbatim}
    int sparsity ;
    GxB_get (A, GxB_SPARSITY_STATUS, &sparsity) ; \end{verbatim}}

The sparsity format of a matrix can be controlled with \verb'GxB_set', which
can be any mix (a sum or bitwise or) of \verb'GxB_HYPERSPARSE'
\verb'GxB_SPARSE' \verb'GxB_BITMAP', and \verb'GxB_FULL'.  By default, a matrix
or vector can be held in any format, with the default setting
\verb'GxB_AUTO_SPARSITY', which is equal to \verb'GxB_HYPERSPARSE' +
\verb'GxB_SPARSE' + \verb'GxB_BITMAP' + \verb'GxB_FULL'.  To enable a matrix to
take on just \verb'GxB_SPARSE' or \verb'GxB_FULL' formats, but not
\verb'GxB_HYPERSPARSE' or \verb'GxB_BITMAP', for example, use the following:

{\footnotesize
\begin{verbatim}
    GxB_set (A, GxB_SPARSITY_CONTROL, GxB_SPARSE + GxB_FULL) ; \end{verbatim}}

In this case, SuiteSparse:GraphBLAS will hold the matrix in sparse format
(\verb'CSC' or \verb'CSC', depending on its \verb'GxB_FORMAT'), unless all
entries are present, in which case it will be converted to full format.

Only the least 4 bits of the sparsity control are considered, so the
formats can be bitwise negated.  For example, to allow for any format
except full:

{\footnotesize
\begin{verbatim}
    GxB_set (A, GxB_SPARSITY_CONTROL, ~GxB_FULL) ; \end{verbatim}}

%-------------------------------------------------------------------------------
\subsection{{\sf GxB\_BURBLE}, {\sf GxB\_PRINTF}, {\sf GxB\_FLUSH}: diagnostics}
%-------------------------------------------------------------------------------

\verb'GxB_set (GxB_BURBLE, ...)' controls the burble setting.  It can also be
controlled via \verb'GrB.burble(b)' in the MATLAB/Octave interface.

{\footnotesize
\begin{verbatim}
     GxB_set (GxB_BURBLE, true) ;   // enable burble
     GxB_set (GxB_BURBLE, false) ;  // disable burble \end{verbatim}}

If enabled, SuiteSparse:GraphBLAS reports which internal kernels it uses, and
how much time is spent.  If you see the word \verb'generic', it means that
SuiteSparse:GraphBLAS was unable to use its JIT kernels, or its faster kernels
in \verb'Source/FactoryKernels', but used a generic kernel that relies on
function pointers.  This is done for user-defined types and operators, and when
typecasting is performed, and it is typically slower than the JIT kernels
or kernels in \verb'Source/FactoryKernels'.

If you see a lot of \verb'wait' statements, it may mean that a lot of time is
spent finishing a matrix or vector.  This may be the result of an inefficient
use of the \verb'setElement' and \verb'assign' methods.  If this occurs you
might try changing the sparsity format of a vector or matrix to
\verb'GxB_BITMAP', assuming there's enough space for it.

\verb'GxB_set (GxB_PRINTF, printf)' allows the user application to change the
function used to print diagnostic output.  This also controls the output of the
\verb'GxB_*print' functions.  By default this parameter is \verb'NULL', in
which case the ANSI C11 \verb'printf' function is used.  The parameter is a
function pointer with the same signature as the ANSI C11 \verb'printf'
function.  The MATLAB/Octave interface to GraphBLAS sets it to \verb'mexPrintf'
so that GraphBLAS can print to the MATLAB/Octave Command Window.

After each call to the \verb'printf' function, an optional
\verb'flush' function is called, which is \verb'NULL' by default.  If
\verb'NULL', the function is not used.  This can be changed with
\verb'GxB_set (GxB_FLUSH, flush)'.  The \verb'flush' function takes no
arguments, and returns an \verb'int' which is 0 if successful, or any nonzero
value on failure (the same output as the ANSI C11 \verb'fflush' function,
except that \verb'flush' has no inputs).

%-------------------------------------------------------------------------------
\subsection{Other global options}
%-------------------------------------------------------------------------------

\verb'GxB_MODE' can only be
queried by \verb'GxB_get'; it cannot be modified by \verb'GxB_set'.  The mode
is the value passed to \verb'GrB_init' (blocking or non-blocking).

All threads in the same user application share the same global options,
including hypersparsity, bitmap options, and CSR/CSC format determined by
\verb'GxB_set', and the blocking mode determined by \verb'GrB_init'.
Specific format and hypersparsity parameters of each matrix are specific to
that matrix and can be independently changed.

The \verb'GxB_LIBRARY_*' options can be used with \verb'GxB_get' to query the
current implementation.  For all of these, \verb'GxB_get' returns a string
(\verb'char *'), except for \verb'GxB_LIBRARY_VERSION', which takes as input an
\verb'int' array of size three.  The \verb'GxB_API_*' options can be used with
\verb'GxB_get' to query the current GraphBLAS C API Specification.  For all of
these, \verb'GxB_get' returns a string (\verb'char *'), except for
\verb'GxB_API_VERSION', which takes as input an \verb'int' array of size three.

%===============================================================================
\subsection{{\sf GxB\_Global\_Option\_set:} set a global option}
%===============================================================================

\begin{mdframed}[userdefinedwidth=6in]
{\footnotesize
\begin{verbatim}
GrB_Info GxB_set                    // set a global default option
(
    const GxB_Option_Field field,   // option to change
    ...                             // value to change it to
) ;
\end{verbatim} } \end{mdframed}

This usage of \verb'GxB_set' sets the value of a global option.
The \verb'field' parameter can be
\verb'GxB_HYPER_SWITCH',
\verb'GxB_BITMAP_SWITCH',
\verb'GxB_FORMAT',
\verb'GxB_NTHREADS',
\verb'GxB_CHUNK',
\verb'GxB_BURBLE',
\verb'GxB_PRINTF',
\verb'GxB_FLUSH',
\verb'GxB_PRINT_1BASED', \newline
\verb'GxB_JIT_C_COMPILER_NAME',
\verb'GxB_JIT_C_COMPILER_FLAGS',
\verb'GxB_JIT_C_LINKER_FLAGS',
\verb'GxB_JIT_C_LIBRRIES',
\verb'GxB_JIT_C_PREFACE',
\verb'GxB_JIT_C_CONTROL',
\verb'GxB_JIT_USE_CMAKE',
\verb'GxB_JIT_ERROR_LOG', or
\verb'GxB_JIT_CACHE_PATH'.

For example, the following usage sets the global hypersparsity ratio to 0.2,
the format of future matrices to \verb'GxB_BY_COL', the maximum number
of threads to 4, the chunk size to 10000, and enables the burble.
No existing matrices are changed.

{\footnotesize
\begin{verbatim}
    GxB_set (GxB_HYPER_SWITCH, 0.2) ;
    GxB_set (GxB_FORMAT, GxB_BY_COL) ;
    GxB_set (GxB_NTHREADS, 4) ;
    GxB_set (GxB_CHUNK, (double) 10000) ;
    GxB_set (GxB_BURBLE, true) ;
    GxB_set (GxB_PRINTF, mexPrintf) ;
\end{verbatim} }

\newpage
%===============================================================================
\subsection{{\sf GxB\_Matrix\_Option\_set:} set a matrix option}
%===============================================================================

\begin{mdframed}[userdefinedwidth=6in]
{\footnotesize
\begin{verbatim}
GrB_Info GxB_set                    // set an option in a matrix
(
    GrB_Matrix A,                   // matrix to modify
    const GxB_Option_Field field,   // option to change
    ...                             // value to change it to
) ;
\end{verbatim} } \end{mdframed}

This usage of \verb'GxB_set' sets the value of a matrix option, for a
particular matrix.
The \verb'field' parameter can be
\verb'GxB_HYPER_SWITCH',
\verb'GxB_BITMAP_SWITCH',
\verb'GxB_SPARSITY_CONTROL', or
\verb'GxB_FORMAT'.
This example usage sets the hypersparsity ratio to 0.2, and the
format of \verb'GxB_BY_COL', for a particular matrix \verb'A', and sets the
sparsity control to \verb'GxB_SPARSE+GxB_FULL' (allowing the matrix to be held
in CSC or FullC formats, but not BitmapC or HyperCSC):

{\footnotesize
\begin{verbatim}
    GxB_set (A, GxB_HYPER_SWITCH, 0.2) ;
    GxB_set (A, GxB_FORMAT, GxB_BY_COL) ;
    GxB_set (A, GxB_SPARSITY_CONTROL, GxB_SPARSE + GxB_FULL) ;
\end{verbatim} }

SuiteSparse:GraphBLAS currently applies these changes immediately, but since
they are simply hints, future versions of SuiteSparse:GraphBLAS may delay the
change in format if it can obtain better performance.  If the setting is just
\verb'GxB_FULL' and some entries are missing, then the matrix is held in bitmap
format.  For best performance, the matrix option should be set as soon as it is
created with \verb'GrB_Matrix_new', so the internal transformation takes less
time.  If an error occurs, \verb'GrB_error(&err,A)' returns details about the
error.

%===============================================================================
\subsection{{\sf GxB\_Desc\_set:} set a {\sf GrB\_Descriptor} value}
%===============================================================================
\label{gxbset}

\begin{mdframed}[userdefinedwidth=6in]
{\footnotesize
\begin{verbatim}
GrB_Info GxB_set                // set a parameter in a descriptor
(
    GrB_Descriptor desc,        // descriptor to modify
    const GrB_Desc_Field field, // parameter to change
    ...                         // value to change it to
) ;
\end{verbatim} } \end{mdframed}

This usage is similar to \verb'GrB_Descriptor_set', just with a name that is
consistent with the other usages of this generic function.  Unlike
\verb'GrB_Descriptor_set', the \verb'field' may also be
\verb'GxB_SORT', \verb'GxB_COMPRESSION', or
\verb'GxB_IMPORT'.  Refer to Sections~\ref{descriptor_set}~and~\ref{desc_set}
for details.  If an error occurs, \verb'GrB_error(&err,desc)' returns details
about the error.

\newpage
%===============================================================================
\subsection{{\sf GxB\_Global\_Option\_get:} retrieve a global option}
%===============================================================================
\label{gxbget}

\begin{mdframed}[userdefinedwidth=6in]
{\footnotesize
\begin{verbatim}
GrB_Info GxB_get                    // gets the current global default option
(
    const GxB_Option_Field field,   // option to query
    ...                             // return value of the global option
) ;
\end{verbatim} } \end{mdframed}

This usage of \verb'GxB_get' retrieves the value of a global option.  The
\verb'field' parameter can be one of the following:

\vspace{0.2in}
{\footnotesize
\begin{tabular}{ll}
        \hline
        \verb'GxB_HYPER_SWITCH'         & sparse/hyper setting \\
        \verb'GxB_BITMAP_SWITCH'        & bitmap/sparse setting \\
        \verb'GxB_FORMAT'               & by row/col setting \\
        \verb'GxB_MODE'                 & blocking / non-blocking \\
        \verb'GxB_NTHREADS'             & default number of threads \\
        \verb'GxB_CHUNK'                & default chunk size \\
        \verb'GxB_BURBLE'       & burble setting \\
        \verb'GxB_PRINTF'       & printf function \\
        \verb'GxB_FLUSH'        & flush function \\
        \verb'GxB_PRINT_1BASED' & for printing matrices/vectors \\
        \hline
        \verb'GxB_JIT_C_COMPILER_NAME'  & C compiler for JIT kernels \\
        \verb'GxB_JIT_C_COMPILER_FLAGS' & flags for the C compiler \\
        \verb'GxB_JIT_C_LINKER_FLAGS'   & link flags for the C compiler \\
        \verb'GxB_JIT_C_LIBRARIES'      & libraries to link against \\
        \verb'GxB_JIT_C_CMAKE_LIBS'     & libraries to link against \\
        \verb'GxB_JIT_C_PREFACE'        & preface for JIT kernels \\
        \verb'GxB_JIT_C_CONTROL'        & CPU JIT control \\
        \verb'GxB_JIT_USE_CMAKE'        & CPU JIT: use cmake or not \\ 
        \verb'GxB_JIT_ERROR_LOG'        & error log file \\
        \verb'GxB_JIT_CACHE_PATH'       & folder with compiled kernels \\
        \hline
        \verb'GxB_LIBRARY_NAME'         & the string
                                        \verb'"SuiteSparse:GraphBLAS"' \\
        \verb'GxB_LIBRARY_VERSION'      & \verb'int' array of size 3 \\
        \verb'GxB_LIBRARY_DATE'         & date of release \\
        \verb'GxB_LIBRARY_ABOUT'        & author, copyright \\
        \verb'GxB_LIBRARY_LICENSE'      & license for the library \\
        \verb'GxB_LIBRARY_COMPILE_DATE' & date of compilation \\
        \verb'GxB_LIBRARY_COMPILE_TIME' & time of compilation \\
        \verb'GxB_LIBRARY_OPENMP'       & library compiled with OpenMP\\
        \verb'GxB_LIBRARY_URL'          & URL of the library \\
        \hline
        \verb'GxB_API_VERSION'  & GraphBLAS C API Specification Version \\
        \verb'GxB_API_DATE'     & date of the C API Spec.  \\
        \verb'GxB_API_ABOUT'    & about of the C API Spec. \\
        \verb'GxB_API_URL'      & URL of the specification \\
        \hline
\end{tabular}
}
\vspace{0.2in}

{\bf NOTE:} The strings returned by \verb'GxB_get' are \verb'const char *'.
They are ``owned'' by the GraphBLAS library itself, not by the user
application.  They cannot be freed or modified in any way.  A subsequent call
to \verb'GxB_set' can free them and reallocate them, so they are only valid
until that point.  If you want to keep a string returned by \verb'GxB_get',
make a copy immediately after calling \verb'GxB_get', into a character array
owned by the user application.  The \verb'GxB_JIT_*' strings are the only ones
this affects.

Below is an example:

{\footnotesize
\begin{verbatim}
    double h ;
    GxB_get (GxB_HYPER_SWITCH, &h) ;
    printf ("hyper_switch = %g for all new matrices\n", h) ;

    double b [GxB_BITMAP_SWITCH] ;
    GxB_get (GxB_BITMAP_SWITCH, b) ;
    for (int k = 0 ; k < GxB_NBITMAP_SWITCH ; k++)
    {
        printf ("bitmap_switch [%d] = %g ", k, b [k]) ;
        if (k == 0)
        {
            printf ("for vectors and matrices with 1 row or column\n") ;
        }
        else if (k == GxB_NBITMAP_SWITCH - 1)
        {
            printf ("for matrices with min dimension > %d\n", 1 << (k-1)) ;
        }
        else
        {
            printf ("for matrices with min dimension %d to %d\n",
                (1 << (k-1)) + 1, 1 << k) ;
        }
    }

    GxB_Format_Value s ;
    GxB_get (GxB_FORMAT, &s) ;
    if (s == GxB_BY_COL) printf ("all new matrices are stored by column\n") ;
    else printf ("all new matrices are stored by row\n") ;

    GrB_mode mode ;
    GxB_get (GxB_MODE, &mode) ;
    if (mode == GrB_BLOCKING) printf ("GrB_init(GrB_BLOCKING) was called.\n") ;
    else printf ("GrB_init(GrB_NONBLOCKING) was called.\n") ;

    int nthreads_max ;
    GxB_get (GxB_NTHREADS, &nthreads_max) ;
    printf ("max # of threads to use: %d\n", nthreads_max) ;

    double chunk ;
    GxB_get (GxB_CHUNK, &chunk) ;
    printf ("chunk size: %g\n", chunk) ;

    char *name ;
    int ver [3] ;
    GxB_get (GxB_LIBRARY_NAME, &name) ;
    GxB_get (GxB_LIBRARY_VERSION, ver) ;
    printf ("Library %s, version %d.%d.%d\n", name, ver [0], ver [1], ver [2]) ; \end{verbatim} }

%===============================================================================
\subsection{{\sf GxB\_Matrix\_Option\_get:} retrieve a matrix option}
%===============================================================================

\begin{mdframed}[userdefinedwidth=6in]
{\footnotesize
\begin{verbatim}
GrB_Info GxB_get                    // gets the current option of a matrix
(
    GrB_Matrix A,                   // matrix to query
    GxB_Option_Field field,         // option to query
    ...                             // return value of the matrix option
) ;
\end{verbatim} } \end{mdframed}

This usage of \verb'GxB_get' retrieves the value of a matrix option.  The
\verb'field' parameter can be
\verb'GxB_HYPER_SWITCH',
\verb'GxB_BITMAP_SWITCH',
\verb'GxB_SPARSITY_CONTROL',
\verb'GxB_SPARSITY_STATUS',
or
\verb'GxB_FORMAT'.
For example:

\vspace{-0.1in}
{\footnotesize
\begin{verbatim}
    double h, b  ;
    int sparsity, scontrol ;
    GxB_get (A, GxB_SPARSITY_STATUS, &sparsity) ;
    GxB_get (A, GxB_HYPER_SWITCH, &h) ;
    printf ("matrix A has hyper_switch = %g\n", h) ;
    GxB_get (A, GxB_BITMAP_SWITCH, &b) ;
    printf ("matrix A has bitmap_switch = %g\n", b) ;
    switch (sparsity)
    {
        case GxB_HYPERSPARSE: printf ("matrix A is hypersparse\n") ; break ;
        case GxB_SPARSE:      printf ("matrix A is sparse\n"     ) ; break ;
        case GxB_BITMAP:      printf ("matrix A is bitmap\n"     ) ; break ;
        case GxB_FULL:        printf ("matrix A is full\n"       ) ; break ;
    }
    GxB_Format_Value s ;
    GxB_get (A, GxB_FORMAT, &s) ;
    printf ("matrix A is stored by %s\n", (s == GxB_BY_COL) ? "col" : "row") ;
    GxB_get (A, GxB_SPARSITY_CONTROL, &scontrol) ;
    if (scontrol & GxB_HYPERSPARSE) printf ("A may become hypersparse\n") ;
    if (scontrol & GxB_SPARSE     ) printf ("A may become sparse\n") ;
    if (scontrol & GxB_BITMAP     ) printf ("A may become bitmap\n") ;
    if (scontrol & GxB_FULL       ) printf ("A may become full\n") ; \end{verbatim} }

%===============================================================================
\subsection{{\sf GxB\_Desc\_get:} retrieve a {\sf GrB\_Descriptor} value}
%===============================================================================

\begin{mdframed}[userdefinedwidth=6in]
{\footnotesize
\begin{verbatim}
GrB_Info GxB_get                // get a parameter from a descriptor
(
    GrB_Descriptor desc,        // descriptor to query; NULL means defaults
    GrB_Desc_Field field,       // parameter to query
    ...                         // value of the parameter
) ;
\end{verbatim} } \end{mdframed}

This usage is the same as \verb'GxB_Desc_get'.  The \verb'field' parameter can
be \verb'GrB_OUTP', \verb'GrB_MASK', \verb'GrB_INP0', \verb'GrB_INP1',
\verb'GxB_AxB_METHOD',
\verb'GxB_SORT',
\verb'GxB_COMPRESSION', or
\verb'GxB_IMPORT'.
Refer to Section~\ref{desc_get} for details.

%===============================================================================
\subsection{Summary of usage of {\sf GxB\_set} and {\sf GxB\_get}}
%===============================================================================

The different usages of \verb'GxB_set' and \verb'GxB_get' are summarized below.

\noindent
To set/get the global options:

    {\footnotesize
    \begin{verbatim}
    GxB_set (GxB_HYPER_SWITCH, double h) ;
    GxB_set (GxB_HYPER_SWITCH, GxB_ALWAYS_HYPER) ;
    GxB_set (GxB_HYPER_SWITCH, GxB_NEVER_HYPER) ;
    GxB_get (GxB_HYPER_SWITCH, double *h) ;
    double b [GxB_NBITMAP_SWITCH] ;
    GxB_set (GxB_BITMAP_SWITCH, b) ;
    GxB_set (GxB_BITMAP_SWITCH, NULL) ;     // set defaults
    GxB_get (GxB_BITMAP_SWITCH, b) ;
    GxB_set (GxB_FORMAT, GxB_BY_ROW) ;
    GxB_set (GxB_FORMAT, GxB_BY_COL) ;
    GxB_get (GxB_FORMAT, GxB_Format_Value *s) ;
    GxB_set (GxB_NTHREADS, int nthreads_max) ;
    GxB_get (GxB_NTHREADS, int *nthreads_max) ;
    GxB_set (GxB_CHUNK, double chunk) ;
    GxB_get (GxB_CHUNK, double *chunk) ;
    GxB_set (GxB_BURBLE, bool burble) ;
    GxB_get (GxB_BURBLE, bool *burble) ;
    GxB_set (GxB_PRINTF, void *printf_function) ;
    GxB_get (GxB_PRINTF, void **printf_function) ;
    GxB_set (GxB_FLUSH, void *flush_function) ;
    GxB_get (GxB_FLUSH, void **flush_function) ;
    GxB_set (GxB_PRINT_1BASED, bool onebased) ;
    GxB_get (GxB_PRINT_1BASED, bool *onebased) ;

    GxB_set (GxB_JIT_C_COMPILER_NAME, char *compiler) ;
    GxB_get (GxB_JIT_C_COMPILER_NAME, char **compiler) ;
    GxB_set (GxB_JIT_C_COMPILER_FLAGS, char *flags) ;
    GxB_get (GxB_JIT_C_COMPILER_FLAGS, char **flags) ;
    GxB_set (GxB_JIT_C_LINKER_FLAGS, char *flags) ;
    GxB_get (GxB_JIT_C_LINKER_FLAGS, char **flags) ;
    GxB_set (GxB_JIT_C_LIBRARIES, char *libraries) ;
    GxB_get (GxB_JIT_C_LIBRARIES, char **libraries) ;
    GxB_set (GxB_JIT_C_CMAKE_LIBS, char *libraries) ;
    GxB_get (GxB_JIT_C_CMAKE_LIBS, char **libraries) ;
    GxB_set (GxB_JIT_C_PREFACE, char *preface) ;
    GxB_get (GxB_JIT_C_PREFACE, char **preface) ;
    GxB_set (GxB_JIT_ERROR_LOG, char *error_log) ;
    GxB_get (GxB_JIT_ERROR_LOG, char **error_log) ;
    GxB_set (GxB_JIT_CACHE_PATH, char *cache) ;
    GxB_get (GxB_JIT_CACHE_PATH, char **cache) ;
    GxB_set (GxB_JIT_USE_CMAKE, int use_cmake) ;
    GxB_get (GxB_JIT_USE_CMAKE, int *use_cmake) ;
    GxB_set (GxB_JIT_C_CONTROL, int control) ;
    GxB_get (GxB_JIT_C_CONTROL, int *control) ;
    \end{verbatim} }

\noindent
To get global options that can be queried but not modified:

    {\footnotesize
    \begin{verbatim}
    GxB_get (GxB_MODE,                 GrB_Mode *mode) ;
    GxB_get (GxB_LIBRARY_NAME,         char **) ;
    GxB_get (GxB_LIBRARY_VERSION,      int *) ;
    GxB_get (GxB_LIBRARY_DATE,         char **) ;
    GxB_get (GxB_LIBRARY_ABOUT,        char **) ;
    GxB_get (GxB_LIBRARY_LICENSE,      char **) ;
    GxB_get (GxB_LIBRARY_COMPILE_DATE, char **) ;
    GxB_get (GxB_LIBRARY_COMPILE_TIME, char **) ;
    GxB_get (GxB_LIBRARY_OPENMP,       bool *) ;
    GxB_get (GxB_LIBRARY_URL,          char **) ;
    GxB_get (GxB_API_VERSION,          int *) ;
    GxB_get (GxB_API_DATE,             char **) ;
    GxB_get (GxB_API_ABOUT,            char **) ;
    GxB_get (GxB_API_URL,              char **) ; \end{verbatim} }

\noindent
To set/get a matrix option or status

    {\footnotesize
    \begin{verbatim}
    GxB_set (GrB_Matrix A, GxB_HYPER_SWITCH, double h) ;
    GxB_set (GrB_Matrix A, GxB_HYPER_SWITCH, GxB_ALWAYS_HYPER) ;
    GxB_set (GrB_Matrix A, GxB_HYPER_SWITCH, GxB_NEVER_HYPER) ;
    GxB_get (GrB_Matrix A, GxB_HYPER_SWITCH, double *h) ;
    GxB_set (GrB_Matrix A, GxB_BITMAP_SWITCH, double b) ;
    GxB_get (GrB_Matrix A, GxB_BITMAP_SWITCH, double *b) ;
    GxB_set (GrB_Matrix A, GxB_FORMAT, GxB_BY_ROW) ;
    GxB_set (GrB_Matrix A, GxB_FORMAT, GxB_BY_COL) ;
    GxB_get (GrB_Matrix A, GxB_FORMAT, GxB_Format_Value *s) ;
    GxB_set (GrB_Matrix A, GxB_SPARSITY_CONTROL, GxB_AUTO_SPARSITY) ;
    GxB_set (GrB_Matrix A, GxB_SPARSITY_CONTROL, scontrol) ;
    GxB_get (GrB_Matrix A, GxB_SPARSITY_CONTROL, int *scontrol) ;
    GxB_get (GrB_Matrix A, GxB_SPARSITY_STATUS, int *sparsity) ; \end{verbatim} }

\noindent
To set/get a vector option or status:

    {\footnotesize
    \begin{verbatim}
    GxB_set (GrB_Vector v, GxB_BITMAP_SWITCH, double b) ;
    GxB_get (GrB_Vector v, GxB_BITMAP_SWITCH, double *b) ;
    GxB_set (GrB_Vector v, GxB_FORMAT, GxB_BY_ROW) ;
    GxB_set (GrB_Vector v, GxB_FORMAT, GxB_BY_COL) ;
    GxB_get (GrB_Vector v, GxB_FORMAT, GxB_Format_Value *s) ;
    GxB_set (GrB_Vector v, GxB_SPARSITY_CONTROL, GxB_AUTO_SPARSITY) ;
    GxB_set (GrB_Vector v, GxB_SPARSITY_CONTROL, scontrol) ;
    GxB_get (GrB_Vector v, GxB_SPARSITY_CONTROL, int *scontrol) ;
    GxB_get (GrB_Vector v, GxB_SPARSITY_STATUS, int *sparsity) ; \end{verbatim} }

\noindent
To set/get a descriptor field:

    {\footnotesize
    \begin{verbatim}
    GxB_set (GrB_Descriptor d, GrB_OUTP, GrB_DEFAULT) ;
    GxB_set (GrB_Descriptor d, GrB_OUTP, GrB_REPLACE) ;
    GxB_get (GrB_Descriptor d, GrB_OUTP, GrB_Desc_Value *v) ;
    GxB_set (GrB_Descriptor d, GrB_MASK, GrB_DEFAULT) ;
    GxB_set (GrB_Descriptor d, GrB_MASK, GrB_COMP) ;
    GxB_set (GrB_Descriptor d, GrB_MASK, GrB_STRUCTURE) ;
    GxB_set (GrB_Descriptor d, GrB_MASK, GrB_COMP+GrB_STRUCTURE) ;
    GxB_get (GrB_Descriptor d, GrB_MASK, GrB_Desc_Value *v) ;
    GxB_set (GrB_Descriptor d, GrB_INP0, GrB_DEFAULT) ;
    GxB_set (GrB_Descriptor d, GrB_INP0, GrB_TRAN) ;
    GxB_get (GrB_Descriptor d, GrB_INP0, GrB_Desc_Value *v) ;
    GxB_set (GrB_Descriptor d, GrB_INP1, GrB_DEFAULT) ;
    GxB_set (GrB_Descriptor d, GrB_INP1, GrB_TRAN) ;
    GxB_get (GrB_Descriptor d, GrB_INP1, GrB_Desc_Value *v) ;
    GxB_set (GrB_Descriptor d, GxB_AxB_METHOD, GrB_DEFAULT) ;
    GxB_set (GrB_Descriptor d, GxB_AxB_METHOD, GxB_AxB_GUSTAVSON) ;
    GxB_set (GrB_Descriptor d, GxB_AxB_METHOD, GxB_AxB_HASH) ;
    GxB_set (GrB_Descriptor d, GxB_AxB_METHOD, GxB_AxB_SAXPY) ;
    GxB_set (GrB_Descriptor d, GxB_AxB_METHOD, GxB_AxB_DOT) ;
    GxB_get (GrB_Descriptor d, GrB_AxB_METHOD, GrB_Desc_Value *v) ;
    GxB_set (GrB_Descriptor d, GxB_SORT, sort) ;
    GxB_get (GrB_Descriptor d, GxB_SORT, int *sort) ;
    GxB_set (GrB_Descriptor d, GxB_COMPRESSION, GxB_FAST_IMPORT) ;
    GxB_set (GrB_Descriptor d, GxB_COMPRESSION, GxB_SECURE_IMPORT) ;
    GxB_get (GrB_Descriptor d, GxB_COMPRESSION, GrB_Desc_Value *method) ;
    GxB_set (GrB_Descriptor d, GxB_IMPORT, int method) ;
    GxB_get (GrB_Descriptor d, GxB_IMPORT, int *method) ; \end{verbatim} }


