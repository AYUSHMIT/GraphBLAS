    C = abs (G) ;
    C = all (G, option) ;
    p = amd (G, varargin) ;
    C = and (A, B) ;
    C = any (G, option) ;
    Cout = apply (varargin) ;
    assert (G) ;
    Cout = assign (varargin) ;
    [arg1,arg2] = bandwidth (G,uplo) ;
    binopinfo (op, type) ;
    G = build (varargin) ;
    C = ceil (G) ;
    c = chunk (varargin) ;
    clear ;
    [p, varargout] = colamd (G, varargin) ;
    D = coldegree (G) ;
    C = complex (A,B) ;
    C = conj (G) ;
    C = ctranspose (A) ;
    descriptorinfo (d) ;
    C = diag (G,k) ;
    display (G) ;
    disp (G, level) ;
    [p, varargout] = dmperm (G) ;
    C = double (G) ;
    Cout = eadd (varargin) ;
    [V, varargout] = eig (G, varargin) ;
    G = empty (arg1, arg2) ;
    Cout = emult (varargin) ;
    index = end (G, k, ndims) ;
    C = eps (G) ;
    C = eq (A, B) ;
    [parent, varargout] = etree (G, varargin) ;
    C = expand (scalar, S) ;
    Cout = extract (varargin) ;
    [I,J,X] = extracttuples (varargin) ;
    C = eye (varargin) ;
    C = false (varargin) ;
    [I, J, X] = find (G) ;
    C = fix (G) ;
    C = floor (G) ;
    f = format (arg) ;
    F = full (X, type, identity) ;
    Cout = gbkron (varargin) ;
    classdef gb ;
    Cout = gbtranspose (varargin) ;
    C = ge (A, B) ;
    C = gt (A, B) ;
    C = horzcat (varargin) ;
    C = int16 (G) ;
    C = int32 (G) ;
    C = int64 (G) ;
    C = int8 (G) ;
    s = isa (G, classname) ;
    result = isbanded (G, lo, hi) ;
    result = isdiag (G) ;
    s = isempty (G) ;
    C = isfinite (G) ;
    s = isfloat (G) ;
    result = ishermitian (G, option) ;
    C = isinf (G) ;
    s = isinteger (G) ;
    s = islogical (G) ;
    s = ismatrix (G) ;
    C = isnan (G) ;
    s = isnumeric (G) ;
    s = isreal (G) ;
    s = isscalar (G) ;
    s = issigned (type) ;
    s = issparse (G) ;
    result = issymmetric (G, option) ;
    result = istril (G) ;
    result = istriu (G) ;
    s = isvector (G) ;
    C = kron (A, B) ;
    C = ldivide (A, B) ;
    C = le (A, B) ;
    n = length (G) ;
    C = logical (G) ;
    C = lt (A, B) ;
    C = max (varargin) ;
    C = min (varargin) ;
    C = minus (A, B) ;
    C = mldivide (A, B) ;
    monoidinfo (monoid, type) ;
    C = mpower (A, B) ;
    C = mrdivide (A, B) ;
    C = mtimes (A, B) ;
    Cout = mxm (varargin) ;
    C = ne (A, B) ;
    e = nnz (G) ;
    X = nonzeros (G) ;
    s = norm (G,kind) ;
    C = not (A) ;
    result = numel (G) ;
    e = nvals (A) ;
    e = nzmax (G) ;
    C = ones (varargin) ;
    C = or (A, B) ;
    C = plus (A, B) ;
    C = power (A, B) ;
    C = prod (G, option) ;
    C = rdivide (A, B) ;
    C = real (G) ;
    Cout = reduce (varargin) ;
    C = repmat (G, m, n) ;
    C = reshape (G, arg1, arg2) ;
    C = round (G) ;
    D = rowdegree (G) ;
    Cout = select (varargin) ;
    semiringinfo (s, type) ;
    C = sign (G) ;
    C = single (G) ;
    [arg1 n] = size (G, dim) ;
    S = sparse (G) ;
    C = speye (varargin) ;
    C = spfun (fun, G) ;
    C = spones (G, type) ;
    C = sqrt (G) ;
    Cout = subassign (varargin) ;
    C = subsasgn (C, S, A) ;
    C = subsref (A, S) ;
    C = sum (G, option) ;
    [p, varargout] = symamd (G, varargin) ;
    p = symrcm (G) ;
    nthreads = threads (varargin) ;
    C = times (A, B) ;
    C = transpose (A) ;
    L = tril (G, k) ;
    U = triu (G, k) ;
    s = type (X) ;
    C = uint16 (G) ;
    C = uint32 (G) ;
    C = uint64 (G) ;
    C = uint8 (G) ;
    C = uminus (A) ;
    unopinfo (op, type) ;
    C = uplus (A) ;
    C = vertcat (varargin) ;
    Cout = vreduce (varargin) ;
    C = zeros (varargin) ;
