Here are a list of the Source/*.c files that need to be done in parallel.
I've roughly sorted them by priority.  You can find them all with:

cd GraphBLAS/Source
grep -r PARALLEL .

There are just 38 files to consider in all of GraphBLAS.  The other files
either call these, or do O(1) or O(log(..)) work and won't be done in parallel.

----------------------------------------------------------------------

GB_AxB_parallel.c:
    This is where we do C=A*B, for GrB_mxm, GrB_mxv, and GrB_vxm.  It will do
    all methods: Gustavson, Heap, and Dot.  But needs a code to partition B,
    and another to combine the C submatrices into the single C output matrix.

GB_Sauna_alloc.c:
    not itself parallel, but each thread of Gustavson's method for C=A*B
    will need its own Sauna.  Need to decide where to put the Sauna.

Template/GB_qsort_template.c:
    Does lots of work, everywhere, for many GraphBLAS operations.  A parallel
    in-place quicksort. Should be easy to parallelize as-is.

GB_transplant.c:
    utility function used by almost all of GraphBLAS.  Easy to parallelize.

GB_cast_array.c:
    Typecasts the numerical values, so used everywhere. Easy to parallelize.

GB_add.c:
    C = A+B. Does the work for GrB_*_eWiseAdd, and the accumulator operator.
    Very important.  Need to break the work into symbolic/numeric phases.
    First phase only computes the number of entries in each column of C.

GB_mask.c:
    Does the C<M>=result for all operations.  Important function.  Parallel
    method would look like GB_add.

GB_emult.c:
    Does "C=A.*B" for GrB_*_eWiseMult_*.  Parallelism is a lot like GB_add.

GB_cumsum.c:
    a parallel cumulative-sum.  Easy to parallelize.  Used many places.

GB_build.c, GB_builder.c, GB_build_factory.c:
    does the work of GrB_*_build.  Some is easy to do.  
    Also used by GB_transpose so it is an important function to parallelize.

GB_transpose.c:
    uses two methods, a qsort-based method and a bucket sort.
    The qsort should be done in parallel, but there are some for loops in
    this file that need to be parallel.

GB_reduce_to_scalar.c:
    Does the work for GrB_reduce, to a scalar.  Simple reduction for loop.

GB_reduce_to_column.c:
    does the work for GrB_*_reduce (to a vector)

GB_extractTuples.c:
    does GrB_*_extractTuples.  Easy to parallelize

GB_apply_op.c.c:
    Applies a unary operator for GrB_*_apply.  Easy to parallelize.

Template/GB_prune_inplace.c:
    kills zombies for GrB_wait, and also to resize a matrix by GxB_*_resize.
    Could use a reduction-style parallelism.

GB_to_nonhyper.c, GB_to_hyper.c:
    converts to/from hypersparse and standard.  Important utility,
    easy to parallelize.

GB_wait.c:
    Does the work for GrB_wait for one matrix.  Kills zombies and assembles
    pending tuples.

GB_dup.c:
    does the work for GrB_*_dup.  Easy to parallelize.

GB_resize.c:
    does the work for GxB_*_resize.  Low priority but easy to do.

GB_calloc_memory.c:
    calls the ANSI C calloc function.  If the array is big, this could be
    set to zero in parallel.  Easy to do.

GB_realloc_memory.c:
    calls the ANSI C realloc function.  If the array is big, this could be done
    with a malloc, then a large parallel memcpy, then free the old space. 
    Easy to do.

GB_select.c:
    does the work for my GxB_*_select operations.  This prunes the matrix,
    like GB_prune_inplace.

GB_nvec_nonempty.c:
    counts # of non-empty vectors.  simple parallel reduction.
    Small utility routine used everywhere, but doesn't do a lot of work
    so lower priority.

GB_kron_kernel.c:
    should be easy to do.  Could just precompute the size of each column
    of the output matrix, quickly, and then to a parallel cumulative sum.
    Then fill the output.  But not as essential as the methods above.


----------------------------------------------------------------------
For C=A(I,J) and A(I,J)=C:  some are hard to do
----------------------------------------------------------------------

GB_assign.c:
    Does the work of GrB_*_assign.
    This will be hard, but not impossible.
    Most of the work is in GB_subassign_kernel

Template/GB_subref_template.c:
    Does the work for A=C(I,J).  The list J can be partitioned and this can
    be called in parallel to create independent submatrices, like
    A1 = C(I,J1) where J1 is the first set of columns in J.
    Then the results can be concatenated together, like C=A*B.

GB_subassign_kernel.c:
    This does C(I,J)=A.  Huge file, but could be done in parallel since the
    main pass does not modify the pattern of C at all, except to kill
    entries by making them zombies.  If a new entry is to be added, it gets
    put into a list of pending tuples.  Each thread could make its own list,
    and the lists could be combined when done.

GB_I_inverse.c, GB_ijproperties.c, GB_ijsort.c:
    utility functions for assign and extract (A=C(I,J) and C(I,J)=A).
    I_inverse is hard to parallelize.


----------------------------------------------------------------------
bucket transpose: don't parallelize at all?
----------------------------------------------------------------------

GB_transpose_ix, GB_transpose_op, GB_transpose_bucket
    for the transpose bucket sort.  hard to parallelize but we can
    use the qsort method instead of the bucket method.  So this is low
    priority, if at all.

